<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Очередь — Территория доверия и поддержки</title>
  <link rel="stylesheet" href="styles.css">
</head>

<body>
  <div class="wrap">
    <div class="card">
      <h1>Очередь участников</h1>
      <div class="subtitle">Выберите линию, чтобы стать участником.</div>

      <div class="tabs">
        <button class="tab active" data-line="10">10 ₴</button>
        <button class="tab" data-line="50">50 ₴</button>
        <button class="tab" data-line="100">100 ₴</button>
      </div>

      <div class="queue" id="queueBlock"></div>

      <div class="hint-strong">
        - перечисли первому - займи третье место - получи реф. ссылку
      </div>

      <div class="buttons">
        <button class="btn-main" id="joinBtn">Присоединиться к линии 10 ₴</button>
        <button class="btn-secondary" id="cabinetBtn">Личный кабинет</button>
        <button class="btn-main btn-rules" id="rulesBtn">Правила участия</button>
      </div>
    </div>
  </div>

  <script>
  document.addEventListener("DOMContentLoaded", () => {

    // =========================
    // Концепция (MVP):
    // - queue.html?ref=OWNER_ID показывает "личную очередь" владельца OWNER_ID
    // - если ref есть в URL: это и есть ref_owner (пригласивший) для кандидата
    // - my_id хранится отдельно и генерируется, если его нет
    // =========================

    const qs = (s) => document.querySelector(s);
    const LINES = ["10","50","100"];

    // ----- URL params -----
    function getParams() {
      const p = new URLSearchParams(location.search);
      return {
        ref: p.get("ref") || "",   // владелец очереди (и он же "пригласивший", если кандидат пришёл по ссылке)
        line: p.get("line") || ""
      };
    }

    // ----- localStorage keys -----
    const KEY_ACTIVE_LINE = "active_line";
    const KEY_MY_ID = "my_id";
    const KEY_REF_OWNER = "ref_owner";     // по чьей ссылке пришли (пригласивший)
    const KEY_VIEW_OWNER = "view_owner";   // чью очередь сейчас показываем
    const KEY_STATE = "cabinet_state";     // статусы + profile по линиям (для текущего my_id)
    const KEY_OWNER_QUEUES = "owner_queues"; // очереди владельцев (по ref)

    // ----- my_id generator -----
    function ensureMyId() {
      let myId = localStorage.getItem(KEY_MY_ID);
      if (myId && myId.trim()) return myId;

      // простой генератор, чтобы тесты не ломались
      const rnd = Math.random().toString(16).slice(2, 8).toUpperCase();
      myId = "U" + Date.now().toString(36).toUpperCase() + rnd;
      localStorage.setItem(KEY_MY_ID, myId);
      return myId;
    }

    // ----- state: cabinet_state (для текущего my_id) -----
    function readState() {
      try { return JSON.parse(localStorage.getItem(KEY_STATE) || "{}"); }
      catch { return {}; }
    }
    function writeState(state) {
      localStorage.setItem(KEY_STATE, JSON.stringify(state));
    }

    function ensureDefaults() {
      const state = readState();
      if (!state.lines) state.lines = {};
      LINES.forEach((l) => {
        if (!state.lines[l]) {
          state.lines[l] = {
            status: "none",
            profile: null,
            tree: { level1: [], level2: [] }
          };
        } else {
          if (!("profile" in state.lines[l])) state.lines[l].profile = null;
          if (!state.lines[l].tree) state.lines[l].tree = { level1: [], level2: [] };
          if (!state.lines[l].status) state.lines[l].status = "none";
        }
      });
      writeState(state);
    }

    function hasProfile(lineStr) {
      const state = readState();
      const p = state.lines?.[lineStr]?.profile;
      return !!(p && p.nick && p.goal && p.card);
    }

    // ----- owner queues storage (личные очереди владельцев) -----
    function readOwnerQueues() {
      try { return JSON.parse(localStorage.getItem(KEY_OWNER_QUEUES) || "{}"); }
      catch { return {}; }
    }
    function writeOwnerQueues(obj) {
      localStorage.setItem(KEY_OWNER_QUEUES, JSON.stringify(obj));
    }

    function ensureOwnerQueueSeed(ownerId) {
      const all = readOwnerQueues();
      if (!all[ownerId]) all[ownerId] = {};

      // если у владельца нет очередей — засеем тестовыми (чтобы было что видеть)
      LINES.forEach((l) => {
        if (!Array.isArray(all[ownerId][l]) || all[ownerId][l].length === 0) {
          // можно позже заменить реальными данными из базы
          all[ownerId][l] = getDemoQueue(l);
        }
      });

      writeOwnerQueues(all);
    }

    function getOwnerQueue(ownerId, lineStr) {
      const all = readOwnerQueues();
      return (all[ownerId] && Array.isArray(all[ownerId][lineStr])) ? all[ownerId][lineStr] : [];
    }

    function getDemoQueue(lineStr) {
      // те же тестовые данные, но как "сид" для конкретного ownerId
      if (lineStr === "10") return [
        { nick: "Олена",  card: "5375 **** **** 1234", goal: "Ліки для мами" },
        { nick: "Ігор",   card: "4149 **** **** 5678", goal: "Оплата гуртожитку" },
        { nick: "Наталя", card: "5168 **** **** 9012", goal: "Форма дитині в школу" }
      ];
      if (lineStr === "50") return [
        { nick: "Вадим",  card: "4441 **** **** 2222", goal: "Ремонт авто після ДТП" },
        { nick: "Марія",  card: "4731 **** **** 3333", goal: "Курс навчання" },
        { nick: "Сергій", card: "4149 **** **** 4444", goal: "Тренування сина" }
      ];
      return [
        { nick: "Анна",  card: "5375 **** **** 5555", goal: "Операція для тата" },
        { nick: "Роман", card: "5168 **** **** 6666", goal: "Закрити кредит" },
        { nick: "Юрій",  card: "4149 **** **** 7777", goal: "Почати свій бізнес" }
      ];
    }

    // ----- UI: tabs/active line -----
    let currentLine = "10";

    function setActiveLine(lineStr) {
      currentLine = lineStr;
      localStorage.setItem(KEY_ACTIVE_LINE, String(lineStr));

      // сохраняем line в адресе (удобно для теста)
      const u = new URL(location.href);
      u.searchParams.set("line", String(lineStr));
      history.replaceState({}, "", u);
    }

    function getSavedLine() {
      const saved = localStorage.getItem(KEY_ACTIVE_LINE) || "";
      return LINES.includes(saved) ? saved : "";
    }

    function setTabUI(lineStr) {
      document.querySelectorAll(".tab").forEach(t => {
        t.classList.toggle("active", t.dataset.line === lineStr);
      });
    }

    // ----- render -----
    const queueBlock = qs("#queueBlock");
    const joinBtn = qs("#joinBtn");
    const cabinetBtn = qs("#cabinetBtn");
    const rulesBtn = qs("#rulesBtn");
    const tabs = document.querySelectorAll(".tab");

    function renderQueue(ownerId) {
      const data = getOwnerQueue(ownerId, currentLine);

      if (!data.length) {
        queueBlock.innerHTML = "<div class='hint'>Очередь пуста</div>";
        return;
      }

      let html = "";
      data.slice(0, 3).forEach((item, index) => {
        html += `
          <div class="queue-row">
            <div class="pos">${index + 1}</div>
            <div class="info">
              <div class="nick">${item.nick}</div>
              <div class="card-mask">${item.card}</div>
              <div class="goal">${item.goal}</div>
            </div>
          </div>
        `;
      });

      queueBlock.innerHTML = html;

      joinBtn.textContent = hasProfile(currentLine)
        ? ("Открыть кабинет линии " + currentLine + " ₴")
        : ("Присоединиться к линии " + currentLine + " ₴");
    }

    // ----- INIT -----
    ensureDefaults();

    const { ref, line } = getParams();
    const myId = ensureMyId();

    // ref в URL: чью очередь показываем (владелец ссылки)
    // если ref нет — показываем очередь самого пользователя (myId)
    const viewOwner = (ref && ref.trim()) ? ref.trim() : myId;
    localStorage.setItem(KEY_VIEW_OWNER, viewOwner);

    // Если ref был — значит пришли по ссылке владельца -> запомним пригласившего
    if (ref && ref.trim()) localStorage.setItem(KEY_REF_OWNER, ref.trim());

    // Убедимся, что у владельца есть очереди (сид для теста)
    ensureOwnerQueueSeed(viewOwner);

    const fromUrlLine = LINES.includes(line) ? line : "";
    const startLine = fromUrlLine || getSavedLine() || "10";

    setActiveLine(startLine);
    setTabUI(startLine);
    renderQueue(viewOwner);

    // ----- Tabs -----
    tabs.forEach(tab => {
      tab.addEventListener("click", () => {
        const newLine = tab.dataset.line;
        setActiveLine(newLine);
        setTabUI(newLine);
        renderQueue(viewOwner);
      });
    });

    // ----- Buttons -----

    // Присоединиться:
    // - если профиля нет -> регистрация (отдельная по линии)
    // - если профиль есть -> кабинет
    joinBtn.addEventListener("click", () => {
      const refOwner = localStorage.getItem(KEY_REF_OWNER) || "";
      const common = `line=${encodeURIComponent(currentLine)}${refOwner ? `&ref=${encodeURIComponent(refOwner)}` : ""}`;

      if (!hasProfile(currentLine)) {
        location.href = `register.html?${common}`;
        return;
      }

      // профиль есть -> кабинет
      location.href = `cabinet.html?ref=${encodeURIComponent(myId)}&line=${encodeURIComponent(currentLine)}`;
    });

    // Кабинет: открыть текущую линию
    cabinetBtn.addEventListener("click", () => {
      location.href = `cabinet.html?ref=${encodeURIComponent(myId)}&line=${encodeURIComponent(currentLine)}`;
    });

    // Правила (переход на отдельную страницу rules.html)
rulesBtn.addEventListener("click", () => {
  const p = new URLSearchParams(location.search);

  const ref =
    p.get("ref") ||
    localStorage.getItem("my_id") ||
    "TEST123";

  const line =
    p.get("line") ||
    localStorage.getItem("active_line") ||
    currentLine ||
    "10";

  location.href =
    `rules.html?ref=${encodeURIComponent(ref)}&line=${encodeURIComponent(line)}`;
});


  });
  </script>
</body>
</html>




